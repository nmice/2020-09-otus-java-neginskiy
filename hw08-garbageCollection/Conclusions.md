<h1>Выводы по сравнению различных GC</h1>

Программа была запущена с различными параметрами внутри (Thread.sleep(), size), чтобы время работы 
до ошибки по нехватки памяти составляло ~5мин.  
Для разных типов сборщиков (Serial, Parallel, G1) под минорными сборками подразумеваются соответственно фазы 
Copy, Scavenge и Young Generation.
Под мажорными - MarkSweepCompact, MarkSweep и Old Generation. 


**SerialGC**
<br/>
Параметры запуска:
-XX:+UseSerialGC -Xms1024m -Xmx1024m -Xlog:gc:hw08-garbageCollection/logs/gc_serialgc.log -XX:+HeapDumpOnOutOfMemoryError
При использовании SerialGC заметным недостатком были долгие паузы при сборке, достоинством можно назвать постоянство 
в количестве сборок и времени на их выполнение.
<br/>
<br/>
**ParallelGC**
<br/>
Параметры запуска:
-XX:+UseParallelGC -Xms1024m -Xmx1024m -Xlog:gc:hw08-garbageCollection/logs/gc_parallelgc.log -XX:+HeapDumpOnOutOfMemoryError
При использовании ParallelGC плюсом была явно заметная подстройка сборщика под доступные ресурсы, используемая память 
четко ограничивалась изначально, при этом минусом и следствием является опять же время на сборки. 


**G1GC**
<br/>
Параметры запуска:
-XX:+UseG1GC -Xms1024m -Xmx1024m -Xlog:gc:hw08-garbageCollection/logs/gc_g1gc.log -XX:+HeapDumpOnOutOfMemoryError
При использовании сборщика Garbage First плюсом являются самые маленькие паузы, при этом количество сборок, как мажорных, 
так и минорных самое большое. Это обусловлено значительным использованием сборщиком ресурсов процессора, поэтому
производительность приложения страдает.


***Сравнительная таблица***

|Сборщик |Время работы|minor-сборки|Время сборок|Сред. сборка|major-сборки|Время сборок|Сред. сборка |Макс. сборка|
|:------ |:----------:|:----------:|:----------:|:----------:|:----------:|:----------:|:-----------:|:----------:|
|Serial  |251         |235         |69.7        |296.8       |159         |135.5       | 852.0       |2.0         |
|Parallel|333         |196         |84.6        |431.6       |164         |230.0       | 1402.6      |2.7         |
|G1      |292         |1143        |86.2        |75.4        |260         |152.2       | 585.4       |1.1         |

**Вывод**
<br>
Эксперимент показывает, как ведут себя сборщики при критических нагрузках, вызывающих нехватку 
памяти (время работы до OutOfMemoryError ~5мин).
* Максимальная задержка — максимальное время, на которое сборщик приостанавливает выполнение программы для выполнения 
одной сборки. Такие остановки называются stop-the-world (или STW). Соответственно у самого эффективного сборщика в части 
отзывчивости приложения этот параметр будет минимальным:

    `I G1`
    `II Serial`
    `III Parallel`
    
* Пропускная способность — отношение общего времени работы программы к общему времени простоя, вызванного сборкой 
мусора, на длительном промежутке времени. Соответственно у самого эффективного сборщика в части производительности 
приложения этот параметр также будет минимальным:

    `I G1 - 0.80`
    `II Serial - 0.83`
    `III Parallel - 0.94`

* Потребляемые ресурсы — объем ресурсов процессора и/или дополнительной памяти, потребляемых сборщиком. Соответственно 
эффективный сборщик по этому параметру наименее прожорлив к ресурсам: 

    `I Serial`
    `II Parallel`
    `III G1`

По совокупности факторов (минимум STW с большей эффективностью) для данной программы лучшим сборщиком оказался G1.
Но целесообразность использования сборщика в других ситуациях будет зависеть от ресурсов, самой программы и 
параметров запуска.
